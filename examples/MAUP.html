<html>

    <head>

        <title>Itowns - Globe + WFS</title>
        
            <meta charset="UTF-8">
            <link rel="stylesheet" type="text/css" href="css/example.css">
       <!--  <link rel="stylesheet" type="text/css" href="css/loading_screen.css"> -->
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <!--  <script src="js/GUI/dat.gui/dat.gui.min.js"></script>-->
       <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>

    </head>

    <body>
            <input type="file" id="files" name="files[]" multiple />

        <div id="viewerDiv"></div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="js/GUI/LoadingScreen.js"></script>
        <!-- <script src="js/loading_screen.js"></script> -->
        <!-- <script src="js/proj4defs/3946.js"></script> -->
        <script src="../dist/debug.js"></script>
        <script src="js/jquery-3.3.0.js"></script>
        
        <script type="text/javascript">
         var THREE = itowns.THREE;
           
                
        </script>  

    
   
        
        <script type="text/javascript">
  
  itowns.proj4.defs('EPSG:3946', '+proj=lcc +lat_1=45.25 +lat_2=46.75 +lat_0=46 +lon_0=3 +x_0=1700000 +y_0=5200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');

          

     
 // predefined center of the scene (initial camera position)
var  positionOnGlobe = { longitude:2.418159,  latitude:48.846182  , altitude: 1000 }
var time = 5500;
//var pathTravel = new THREE.Vector3();
var pathTravel = [];

var promises = [];
//camera position based on user's geolocation
var zoomToSelectedObject = function() {

this.ZoomToSelection = function travel() {

var camera = view.camera.camera3D;
itowns.CameraUtils.sequenceAnimationsToLookAtTarget(view, camera, pathTravel);

}

};

//const coords = new itowns.Coordinates('EPSG:4326', positionn.longitude, positionn.latitude, positionn.altitude);
//const positionOnGlobe = coords.as('EPSG:4978');
//pathTravel.push({ range: 1393, time: time * 0.2, tilt: 7.59, heading: -110.9 });
//pathTravel.push({ tilt: 8, time: time * 0.2 });
            var meshes = [];
            //to create global variables to be accessed outside the 'modifyshader' function for the purpose of defining new style 
            var wallsArray = [];
            var roofArray = [];
            var edgesArray = [];
            
            var scaler;
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            // Instanciate iTowns GlobeView*
            var options = {segments:128};  // We specify a high resolution grid (Each tile is 128* 128 * 2 triangles)
            var view = new itowns.GlobeView(viewerDiv, positionOnGlobe, { options });
           // setupLoadingScreen(viewerDiv, view);
            
            var menuGlobe = new GuiTools('menuDiv', view);
            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function init() {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                view.controls.setTilt(45);
               
            });
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);
            function createWMTSSourceFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                return config;
            }
            function addColorLayerFromConfig(config) {
                var layer = new itowns.ColorLayer(config.id, config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
        itowns.Fetcher.json('./layers/JSONLayers/DARK.json').then(createWMTSSourceFromConfig).then(addColorLayerFromConfig);

      
         itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(createWMTSSourceFromConfig).then(addColorLayerFromConfig);
          

            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);
            ////////////building
            var color = new itowns.THREE.Color();

           
            function altitudeBuildings(properties) {
                return properties.z_max - properties.hauteur; //properties.z_min - properties.hauteur;
            }
            function extrudeBuildings(properties) {
                return properties.hauteur;

        
            }
         
         
         function acceptFeature(properties) { 
  
            return !!properties.hauteur;
            }
     

            
            function scaler(/* dt */) {
                var i;
                var mesh;
                if (meshes.length) {
                    view.notifyChange();
                }
                for (i = 0; i < meshes.length; i++) {
                    mesh = meshes[i];
                    mesh.scale.z = Math.min(
                        1.0, mesh.scale.z + 0.1);
                    mesh.updateMatrixWorld(true);
                }
                meshes = meshes.filter(function filter(m) { return m.scale.z < 1; });
            }
            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, scaler);
            
            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '2.0.0',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                projection: 'EPSG:4326',
                ipr: 'IGN',
                //CQL_FILTER: z_min=70.8,
                format: 'application/json',
                zoom: {  min: 15, max:15 }
            });
            // Here we create the geometry layer for the buildings
            // It is pretty easy to do whatever you want as you can write your own Feature2Mesh function
            // or just tune some part of it.
            var wfsBuildingLayer = new itowns.GeometryLayer('WFS Building', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh_R.convert({
                    //color: colorBuildings,
                    batchId: function (property, featureId) {return  featureId},
                    extrude: extrudeBuildings,
                    altitude: altitudeBuildings

                 }),
                onMeshCreated: modifyShader,
                filter: acceptFeature,
                overrideAltitudeInToZero: true,
                source: wfsBuildingSource,
            });
            
           
    view.addLayer(wfsBuildingLayer);//.then(layer => delete layer.opacity);
 
    
    //var arrayEdgesMeshLine1=[]; 

//var arrayEdgesMeshLine1 = [];
   function modifyShader(mesh) {

            // Start with super small scale (scaling effect at load)
            mesh.scale.z = 0.01;
            meshes.push(mesh);
            
            // Get the mesh created ( a group with 3 children)
            // Affect the shader you created
            var walls = mesh.children[0];
            var roof = mesh.children[1];
           var edges = mesh.children[2];
            //var edgess = mesh.children[2];
            if(walls) {
                wallsArray.push(walls);
                
                walls.material = ShadMatWalls;
            }
            if(roof) {
                roofArray.push(roof);
                roof.material = ShadMatRoof;
            }

            if(edges) {
                edgesArray.push(edges);
                
                edges.material = ShadMatEdges;//in order to enable  style on the new loaded tiles
            }

          
 
};




//vertex  shaders
const vertexShader = `
            #include <common>
            #include <logdepthbuf_pars_vertex>

            attribute float zbottom;
            attribute float batchId;
           
            varying vec2 vUv;
            uniform float time;
            uniform vec3 currentPos;
            uniform vec3 centralPosBuffer;
            uniform float bufferDistance;
            uniform float displacement;
            uniform float buildingId;
            uniform float extrusion;
            uniform float queryZbottomMin;
            uniform float queryZbottomMax;
            varying float dist; 
            varying float distCentralPosBuffer; 
            varying vec3 currentPosLocal;
            varying vec3 centralPosBufferLocal;
            varying vec2 bufferDirection;
            varying vec2 displacementDirection;
            varying float vZbottom;
            varying float vBid;


            void main(){
                vUv = uv;
                vec3 newPos = position ; // * (1. + time/10.); // mod(time, 0.001));
                vec4 posAbs = modelMatrix * vec4(newPos, 1.0);
                //dist = distance(posAbs.xyz, currentPos);
                if(dist < 200.) posAbs.xyz *= (1. + (200. - dist)/80000000.);  // newPos += dist / 10.;
                // Let s make like the currentPos attracts the buildings
                // if(dist < 200.) posAbs.xyz = mix(posAbs.xyz, currentPos, 1. - dist/200.);
                vZbottom = zbottom;
                
                vBid = batchId;
                vec4 posFinal = vec4(position, 1.0) ;
                //////////////////////Query buildings based on their vZbottom value/////////////////
                /*if (vZbottom > queryZbottom ){
                    posFinal = posFinal; 
                }
               else {
                posFinal = vec4(0., 0.,0.,1.);
               }*/

/////////////////////////////////buffer analusis////////////////////////////////
            centralPosBufferLocal = centralPosBuffer - modelMatrix[3].xyz;
            bufferDirection = normalize(posFinal.xy - centralPosBufferLocal.xy);
            distCentralPosBuffer = distance(posAbs.xyz, centralPosBuffer);

           /* if (distCentralPosBuffer<bufferDistance)
            {
                posFinal =  posFinal;
            }
            else{
                posFinal = vec4(0., 0.,0.,1.);
            }*/
           /////////////////////////displacement ///////////////////////////
               currentPosLocal = currentPos - modelMatrix[3].xyz;
               displacementDirection = normalize(posFinal.xy - currentPosLocal.xy);
               if (vBid == buildingId){
                posFinal.xy = posFinal.xy;
               }
               else {
                posFinal.xy += displacement * displacementDirection.xy ;
               }
           ////////////////////////////////////////////

//////////////////////   extrusion  //////////////////
            if (vBid == buildingId){
                if (vUv.y == 0.){
                    posFinal.z = posFinal.z;
                }
                else{
                    posFinal.z = posFinal.z + extrusion;
                }
            }
            else{
                posFinal.z = posFinal.z; 
            }
//////////////////////////////////

                gl_Position = projectionMatrix *  modelViewMatrix * posFinal; // modelViewMatrix * vec4(newPos, 1.0);
                #include <logdepthbuf_vertex>
            }
            `;
// Fragment shaders
      
            const fragmentShader_walls = `
            #extension GL_OES_standard_derivatives : enable
            #include <common>
            #include <logdepthbuf_pars_fragment>
            
            #define MODE_COLOR   0
            #define MODE_TEXTURE 1
            #define MODE_UV      2
            #define TYP      3

            uniform sampler2D texture_walls;
            uniform sampler2D brush;
            uniform sampler2D texture_walls1;
            uniform sampler2D texture_walls2;
            uniform int mode;
            uniform float buildingId;
            uniform float texture_scale;
            uniform float opacity;
            uniform float Originality;
            uniform float thickness;
            uniform float displacement;
            uniform float zoomLevel;
            uniform float extrusion;
            uniform float queryZbottomMin;
            uniform float queryZbottomMax;
            uniform vec3 color;
            uniform vec3 edgeColor;
            uniform float time;
            uniform vec3 currentPos;
            uniform vec3 centralPosBuffer;
            uniform float bufferDistance;
            varying float distCentralPosBuffer;
            uniform vec3 facadeColor;
            uniform float wallOpacity;
            uniform float styleState;
            
            varying float dist;
            varying float vZbottom;
            varying vec2 vUv;
            varying float vBid;

   
            void main(){
            #include <logdepthbuf_fragment>
            
                vec2 normUV = texture_scale * vec2(vUv.x * 100000. , vUv.y) /*vec2(mod(vUv.x * 10000., 1.), mod(vUv.y * 10000., 1.))*/;
                if(mode == MODE_COLOR){
                    gl_FragColor = texture2D(texture_walls, normUV);
                } else if (mode == MODE_TEXTURE) {
                    gl_FragColor = texture2D(texture_walls1, normUV);
                } else if (mode == MODE_UV) {
                    gl_FragColor = texture2D(texture_walls2, normUV);
                } else if (mode == TYP) {
                    gl_FragColor = vec4(color, opacity);
                } 
                
              
              

                vec4 finalColor1 = vec4(0.310,0.248,0.227, 1.);
                vec4 finalColor2 = vec4(1.,0.,0., 1.);
                float finalOpacity;
             
                vec4 finalTexture = texture2D(texture_walls, vUv);
                vec4 classifiedColor = vec4(1.);
                //classifiedColor = mix(finalColor, finalTexture, finalOpacity);
                     
           
              
            ///////////////////////////////using step function 
//////////////// Equal Interval Classification //////////////////
                float numberOfClasses = 5.;
                float interval = (queryZbottomMax - queryZbottomMin)/numberOfClasses;
/////////////////////////////////////////////////////////////////

            vec3 facadeStyle = vec3(1.);
            if (styleState == 0.){
                facadeStyle = facadeColor;
            }
            else {
                facadeStyle = finalTexture.rgb;
            }
            if (vBid == buildingId){
                float blend = smoothstep(thickness/2., thickness , vUv.x)*(1. - smoothstep(1. - thickness, 1. - thickness/2. , vUv.x))*smoothstep(thickness/2., thickness , vUv.y)*(1. - smoothstep(1. - thickness, 1. -  thickness/2. , vUv.y));

                gl_FragColor = mix(vec4(edgeColor, 1.0), vec4(facadeStyle, wallOpacity), blend);
            }
                /////////// this is for visualizing features based on the query on attribute
                /*else if (vZbottom < queryZbottomMax && vZbottom > queryZbottomMin){
                    gl_FragColor = vec4(1., 1., 0., 1.);
                }*/
                /////////// this is for visualizing features based on buffer analysis
                else if (distCentralPosBuffer<bufferDistance){
                    ////////focus style: typical//////////////
                        
                        float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                        gl_FragColor =mix(vec4(0., 0., 0., 1.0), vec4(1., 1., 0., 1.), blend);
                        
                            if(vZbottom < queryZbottomMin+interval && vZbottom > queryZbottomMin)
                            {
                                float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                                classifiedColor = finalTexture;

                                gl_FragColor = mix(vec4(0., 0., 0., 1.0), classifiedColor, blend);  
                            }
                            else if(vZbottom < queryZbottomMin+(2. * interval) && vZbottom > queryZbottomMin+interval)
                            {
                                float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                                classifiedColor = mix(finalColor2, finalTexture, 0.8);

                                gl_FragColor = mix(vec4(0., 0., 0., 1.0), classifiedColor, blend);  
                            }
                            else if(vZbottom < queryZbottomMin+(3. * interval) && vZbottom > queryZbottomMin+(2. * interval))
                            {
                                float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                                classifiedColor = mix(finalColor2, finalTexture, 0.6);
                            gl_FragColor = mix(vec4(0., 0., 0., 1.0), classifiedColor, blend);  
                            }
                            else if(vZbottom < queryZbottomMin+(4. * interval) && vZbottom > queryZbottomMin+(3. * interval))
                            {
                                float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                                classifiedColor = mix(finalColor2, finalTexture, 0.4);
                            gl_FragColor = mix(vec4(0., 0., 0., 1.0), classifiedColor, blend);  
                            }
                            else if(vZbottom < queryZbottomMin+(5. * interval) && vZbottom > queryZbottomMin+(4. * interval))
                            {
                                float blend = smoothstep(0.01/2., 0.01 , vUv.x)*(1. - smoothstep(1. - 0.01, 1. - 0.01/2. , vUv.x))*smoothstep(0.01/2., 0.01 , vUv.y)*(1. - smoothstep(1. - 0.01, 1. -  0.01/2. , vUv.y));
                                classifiedColor = finalColor2;
                            gl_FragColor = mix(vec4(0., 0., 0., 1.0), classifiedColor, blend);  
                            }
                }
                else  {
                    gl_FragColor = vec4(0.265,0.262,0.264, 0.7);
                }
            
                
            }
            `
            
           
            const fragmentShader_roof = `
            #include <common>
            #include <logdepthbuf_pars_fragment>
            #define MODE_COLOR   0
            #define MODE_TEXTURE 1
            #define MODE_UV      2
            #define TYP      3
            uniform sampler2D texture_roof;
            uniform sampler2D texture_roof1;
            uniform sampler2D texture_roof2;
            uniform float thickness;
            uniform int mode;
            uniform float buildingId;
            uniform float texture_scale;
            uniform float opacity;
            uniform float Originality;
            uniform float zoomLevel;
            uniform float displacement;
            uniform float extrusion;
            uniform float queryZbottomMin;
            uniform float queryZbottomMax;
            uniform vec3 color;
            uniform float time;
            uniform vec3 currentPos;
            uniform vec3 centralPosBuffer;
            uniform float bufferDistance;
            uniform float styleStateRoof;
            uniform vec3 roofColor;
            uniform float roofOpacity;
            varying float distCentralPosBuffer;
            varying float dist;
            varying float vZbottom;
            varying float vBid;
            varying vec2 vUv;
            
            void main(){
            #include <logdepthbuf_fragment>
            vec2 normUV = texture_scale * vUv * 400000.;
            //vec2 normUV = texture_scale * vec2(vUv.x , vUv.y* 100000.);
            normUV.y *= 2.;
            if(mode == MODE_COLOR){
                    gl_FragColor = texture2D(texture_roof, normUV);
                } else if (mode == MODE_TEXTURE) {
                    gl_FragColor = texture2D(texture_roof1, normUV);
                } else if (mode == MODE_UV) {
                    gl_FragColor = texture2D(texture_roof2, normUV);
                } else if (mode == TYP) {
                    gl_FragColor = vec4(color, opacity);
                } 
                ////////////////////////////////////rendering //////////////
                vec4 finalTextureRoof = texture2D(texture_roof, vUv);
                vec4 finalColorRoof = vec4(0., 0., 1., 1.);
                vec4 classifiedColorRoof = vec4(0., 0., 0., 1.);
                //////////////// Equal Interval Classification //////////////////
                float numberOfClasses = 5.;
                float interval = (queryZbottomMax - queryZbottomMin)/numberOfClasses;
/////////////////////////////////////////////////////////////////


                vec3 roofStyle = vec3(1.);
            if (styleStateRoof == 0.){
                roofStyle = roofColor;
            }
            else {
                roofStyle = finalTextureRoof.rgb;
            }
            
              
                if (vBid == buildingId){

                gl_FragColor = vec4(roofStyle, roofOpacity);
            }
                /////////// this is for visualizing features based on the query on attribute
                /*else if (vZbottom < queryZbottomMax && vZbottom > queryZbottomMin){
                    gl_FragColor = vec4(1., 1., 0., 1.);
                }*/
                /////////// this is for visualizing features based on buffer analysis
                else if (distCentralPosBuffer<bufferDistance){
                    ////////focus style: typical//////////////
                    gl_FragColor = vec4(1., 1., 0., 1.);
                       
                    if(vZbottom < queryZbottomMin+interval && vZbottom > queryZbottomMin)
                            {
                                classifiedColorRoof = finalTextureRoof;

                                gl_FragColor = classifiedColorRoof;  
                            }
                            else if(vZbottom < queryZbottomMin+(2. * interval) && vZbottom > queryZbottomMin+interval)
                            {
                                classifiedColorRoof = mix(finalColorRoof, finalTextureRoof, 0.8);

                                gl_FragColor = classifiedColorRoof;  
                            }
                            else if(vZbottom < queryZbottomMin+(3. * interval) && vZbottom > queryZbottomMin+(2. * interval))
                            {
                                classifiedColorRoof = mix(finalColorRoof, finalTextureRoof, 0.6);
                            gl_FragColor = classifiedColorRoof;  
                            }
                            else if(vZbottom < queryZbottomMin+(4. * interval) && vZbottom > queryZbottomMin+(3. * interval))
                            {
                                classifiedColorRoof = mix(finalColorRoof, finalTextureRoof, 0.4);
                            gl_FragColor = classifiedColorRoof;  
                            }
                            else if(vZbottom < queryZbottomMin+(5. * interval) && vZbottom > queryZbottomMin+(4. * interval))
                            {
                                classifiedColorRoof = finalColorRoof;
                            gl_FragColor = classifiedColorRoof;  
                            }

                    }
                else  {
                    gl_FragColor = vec4(1.,1.,1., 1.);
                }




               

              

                
            }
            `;
            const fragmentShader_edges = `
            #include <common>
            #include <logdepthbuf_pars_fragment>
            uniform float opacity;
            uniform vec3 color;
            uniform float time;
            uniform vec3 currentPos;
            uniform vec3 centralPosBuffer;
            uniform float bufferDistance;
            varying float distCentralPosBuffer;
            varying float dist;
            varying float vZbottom;
            uniform float displacement;
            uniform float buildingId;
            uniform float extrusion;

            void main(){
            #include <logdepthbuf_fragment>
                gl_FragColor = vec4(color, opacity);
            }
 
            `;
        //shader implementation

//let time = 0;
            let currentPos = new THREE.Vector3();
            let centralPosBuffer = new THREE.Vector3();
            let texture_walls =   new THREE.TextureLoader().load("textures/wall.png");
            let brush =   new THREE.TextureLoader().load("textures/brush.png");
            let texture_walls1 = new THREE.TextureLoader().load("textures/stone-wall.jpg");
            let texture_walls2 = new THREE.TextureLoader().load("textures/bricks.jpg");
            let texture_roof = new THREE.TextureLoader().load("textures/roof.png");
            let texture_roof1 = new THREE.TextureLoader().load("textures/rooftile.jpg");
            let texture_roof2 = new THREE.TextureLoader().load("textures/smooth.jpg");
            texture_walls.wrapS = THREE.RepeatWrapping;  // wrapS enables to repeat the texture horizontally
            brush.wrapS = THREE.RepeatWrapping;
            texture_walls.wrapT = THREE.RepeatWrapping;
            brush.wrapT = THREE.RepeatWrapping;
            texture_walls1.wrapS = THREE.RepeatWrapping;  
            texture_walls1.wrapT = THREE.RepeatWrapping;
            texture_walls2.wrapS = THREE.RepeatWrapping;  // wrapS enables to repeat the texture horizontally
            texture_walls2.wrapT = THREE.RepeatWrapping;
              // wrapT enables to repeat the texture vertically
            texture_roof.wrapS = THREE.RepeatWrapping;
            texture_roof.wrapT = THREE.RepeatWrapping;
            texture_roof1.wrapS = THREE.RepeatWrapping;
            texture_roof1.wrapT = THREE.RepeatWrapping;
            texture_roof2.wrapS = THREE.RepeatWrapping;
            texture_roof2.wrapT = THREE.RepeatWrapping;


function createMaterial_texture(vShader, fShader, defaultexture) {
// Default parameters taking into account by shaders in their initial state
let uniforms = {
    texture_roof: {type : 'sampler2D', value : texture_roof}, 
    texture_roof1: {type : 'sampler2D', value : texture_roof1},
    texture_roof2: {type : 'sampler2D', value : texture_roof2}, 
    texture_walls: {type : 'sampler2D', value : texture_walls}, // Texture for modelisation of walls
    brush: {type : 'sampler2D', value : brush},
    texture_walls1: {type : 'sampler2D', value : texture_walls1},
    texture_walls2: {type : 'sampler2D', value : texture_walls2},
    mode: {type: 'i', value: 0},                                // Shader mode : it's an integer between 0 and 1 : 0 = color mode, 1 = texture mode
    texture: {type: 'sampler2D', value: defaultexture},
    //color: {type: 'c', value: defaultColor},                    // Default color parameter
    Originality: {type: 'f', value: 0},
    zoomLevel: {type: 'f', value: 14},
    thickness: {type: 'f', value: 0.01},
    buildingId:{type: 'f', value: 9999999},
    opacity: {type: 'f', value: 1.0},                           // Default opacity parameter
    texture_scale : {type: 'f', value: 0.07},                   // Scale factor on texture (float between 0.0 and 1.0)
    time       : {type: 'f', value: time},                      // time to create animation
    displacement: {type: 'f', value: 0},
    currentPos:  new THREE.Uniform(currentPos),                 // Current position in the trace
    centralPosBuffer:  new THREE.Uniform(centralPosBuffer), 
    bufferDistance: {type: 'f', value: 0}, 
    extrusion: {type: 'f', value: 0.},
    queryZbottomMin: {type: 'f', value: 0.},
    queryZbottomMax: {type: 'f', value: 100.},
    edgeColor: {type: 'c', value: new itowns.THREE.Color("rgb(0, 0, 0)")}, 
    facadeColor: {type: 'c', value: new itowns.THREE.Color("rgb(255, 0, 0)")},
    roofColor: {type: 'c', value: new itowns.THREE.Color("rgb(0, 255, 0)")}, 
    wallOpacity : {type: 'f', value: 1},
    roofOpacity : {type: 'f', value: 1},
    styleState: {type: 'f', value: 0},
    styleStateRoof: {type: 'f', value: 0},
};
let meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vShader,
    fragmentShader: fShader,
    transparent: true,
    opacity: 0.2,
    side: THREE.DoubleSide
});
return meshMaterial;
}
function createMaterial_color(vShader, fShader, defaultColor) {
// Default parameters taking into account by shaders in their initial state
let uniforms = {
   
    mode: {type: 'i', value: 3},                                // Shader mode : it's an integer between 0 and 1 : 0 = color mode, 1 = texture mode
    //texture: {type: 'sampler2D', value: defaultexture},

    color: {type: 'c', value: defaultColor},                    // Default color parameter
    Originality: {type: 'f', value: 0},
    opacity: {type: 'f', value: 1},                           // Default opacity parameter
    texture_scale : {type: 'f', value: 0.03},                   // Scale factor on texture (float between 0.0 and 1.0)
    time       : {type: 'f', value: time},                      // time to create animation
    currentPos:  new THREE.Uniform(currentPos),  
    
};
let meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vShader,
    fragmentShader: fShader,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
});
return meshMaterial;
}
function createMaterial_opacity_wall(vShader, fShader, defaultColor) {
// Default parameters taking into account by shaders in their initial state
let uniforms = {
   
    mode: {type: 'i', value: 3},                                // Shader mode : it's an integer between 0 and 1 : 0 = color mode, 1 = texture mode
    //texture: {type: 'sampler2D', value: defaultexture},

    color: {type: 'c', value: defaultColor},                    // Default color parameter
    opacity: {type: 'f', value: 0.5},                           // Default opacity parameter
    texture_scale : {type: 'f', value: 0.03},                   // Scale factor on texture (float between 0.0 and 1.0)
    time       : {type: 'f', value: time},                      // time to create animation
    currentPos:  new THREE.Uniform(currentPos),                 // Current position in the trace
    
};
let meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vShader,
    fragmentShader: fShader,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
});
return meshMaterial;
}
function createMaterial_opacity_roof(vShader, fShader, defaultColor) {
// Default parameters taking into account by shaders in their initial state
let uniforms = {
   
    mode: {type: 'i', value: 3},                                // Shader mode : it's an integer between 0 and 1 : 0 = color mode, 1 = texture mode
    //texture: {type: 'sampler2D', value: defaultexture},

    color: {type: 'c', value: defaultColor},                    // Default color parameter
    opacity: {type: 'f', value: 0.8},                           // Default opacity parameter
    texture_scale : {type: 'f', value: 0.03},                   // Scale factor on texture (float between 0.0 and 1.0)
    time       : {type: 'f', value: time},                      // time to create animation
    currentPos:  new THREE.Uniform(currentPos),                 // Current position in the trace
    
};
let meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vShader,
    fragmentShader: fShader,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide
});
return meshMaterial;
}
 


var ShadMatRoof = createMaterial_texture(vertexShader, fragmentShader_roof, new THREE.Color(0Xa19f9f));
var ShadMatRoof_ = createMaterial_color(vertexShader, fragmentShader_roof, new THREE.Color(0Xa19f9f));
var ShadMatRoof_typ  = createMaterial_color(vertexShader, fragmentShader_roof, new THREE.Color(0X6c3527)); 
var ShadMatRoof_dis  = createMaterial_opacity_roof(vertexShader, fragmentShader_roof, new THREE.Color(0X000000));
var ShadMatRoof3  = createMaterial_texture(vertexShader, fragmentShader_roof/*, new THREE.TextureLoader().load("textures/roof.png")*/);    
var ShadMatWalls = createMaterial_texture(vertexShader, fragmentShader_walls, new THREE.Color(0Xa19f9f)); 
var ShadMatWalls_ = createMaterial_color(vertexShader, fragmentShader_walls, new THREE.Color(0Xa19f9f));
var ShadMatWalls_ref = new THREE.MeshLambertMaterial({color:0Xffffff, side: THREE.DoubleSide });

var ShadMatWalls_typ = createMaterial_color(vertexShader, fragmentShader_walls, new THREE.Color(0x270906)); 
var ShadMatWalls_dis = createMaterial_opacity_wall(vertexShader, fragmentShader_walls, new THREE.Color(0xffffff));
var ShadMatWalls3 = createMaterial_texture(vertexShader, fragmentShader_walls/*, new THREE.TextureLoader().load("textures/wall.png")*/);

var ShadMatEdges = createMaterial_color(vertexShader, fragmentShader_edges, new THREE.Color(0Xffffff));
var ShadMatEdges_ = createMaterial_color(vertexShader, fragmentShader_edges, new THREE.Color(0Xffffff)); 
var ShadMatEdges_dis_dash = new THREE.LineDashedMaterial({color: 0xffffff, dashSize:1,linewidth: 100, gapSize: 3});
var ShadMatEdges_dis_cont = createMaterial_color(vertexShader, fragmentShader_edges, new THREE.Color(0X666666));
var ShadMatEdges_typ_dash = new THREE.LineDashedMaterial({color: 0xffffff, dashSize:1,linewidth: 100, gapSize: 3});


 
var ShadMatEdges_typ_cont = createMaterial_color(vertexShader, fragmentShader_edges, new THREE.Color(0X070b12));

var ShadMatEdges3 = new THREE.MeshPhongMaterial({
    color: 0X6c3527,
    opacity: 0,
    transparent: true,
  });
  


var Style_criteria = menuGlobe.gui.addFolder('Stylization')
var navv = Style_criteria.addFolder('Select Building');
var façades = Style_criteria.addFolder('Façades')
var Roof = Style_criteria.addFolder('Roof')
var Edges = Style_criteria.addFolder('Edges')




   ////////////////////// user interaction with edges ////////////////////
var Edgethickness = Edges.add({thickness : 0.01}, 'thickness').min(0.01).max(0.15).step(0.001).name('thickness').onChange(
      function originalityValue(m){
        ShadMatWalls.uniforms.thickness.value = m;

        
        view.notifyChange(true);

      }
      );
var EdgeColor = Edges.addColor({edgeColor : ShadMatWalls.uniforms.edgeColor.value.getHex()}, 'edgeColor').onChange(
      function updateColorEdges(value){
        ShadMatWalls.uniforms.edgeColor.value = new THREE.Color(value);
            view.notifyChange(true);
      }
);
////////////////////////////////////////////////////////////////////////////
///////////////user interaction with facades /////////////////////////
var FaçadeStyle = façades.addFolder('Façade Style');
  
            var options = {
               styles: 'Color',
            }; 
var styles = FaçadeStyle.add(options, 'styles', [ "Color", "Texture"]).name('styles').listen();

var colorStyle = FaçadeStyle.addFolder('ColorStyle')
$(colorStyle.domElement).attr("hidden", false);

var FacadeColor = colorStyle.addColor({facadeColor : ShadMatWalls.uniforms.facadeColor.value.getHex()}, 'facadeColor').onChange(
      function updateColorEdges(value){
        ShadMatWalls.uniforms.facadeColor.value = new THREE.Color(value);
            view.notifyChange(true);
      }
);
var FacadeOpacity = colorStyle.add({wallOpacity : 1}, 'wallOpacity').min(0).max(1).step(0.1).onChange(
      function updateOpacityRoof(value){
            ShadMatWalls.uniforms.wallOpacity.value = value;
            view.notifyChange(true);
      }
    );


var textureStyle = FaçadeStyle.addFolder('Texture Style')
$(textureStyle.domElement).attr("hidden", true);

var a = styles.onChange(() => {
    if (options.styles==='Color'){
       $(colorStyle.domElement).attr("hidden", false);
       $(textureStyle.domElement).attr("hidden", true);
        ShadMatWalls.uniforms.styleState.value = 0;
        view.notifyChange();
    }
  
    
    else if (options.styles==='Texture'){
        $(textureStyle.domElement).attr("hidden", false);
        $(colorStyle.domElement).attr("hidden", true);
        ShadMatWalls.uniforms.styleState.value = 1;
        view.notifyChange();
  }
  
  
});
///////////////////////////////////////////user interaction with Roof /////////////////////////
var RoofStyle = Roof.addFolder('Roof Style');
  
            var optionsRoof = {
               stylesRoof: 'Color',
            }; 
var stylesRoof = RoofStyle.add(optionsRoof, 'stylesRoof', [ "Color", "Texture"]).name('styles').listen();

var colorStyleRoof = RoofStyle.addFolder('ColorStyle')
$(colorStyleRoof.domElement).attr("hidden", false);

var RoofColor = colorStyleRoof.addColor({roofColor : ShadMatRoof.uniforms.roofColor.value.getHex()}, 'roofColor').onChange(
      function updateColorEdges(value){
        ShadMatRoof.uniforms.roofColor.value = new THREE.Color(value);
            view.notifyChange(true);
      }
);
var RoofOpacity = colorStyleRoof.add({roofOpacity : 1}, 'roofOpacity').min(0).max(1).step(0.1).onChange(
      function updateOpacityRoof(value){
            ShadMatRoof.uniforms.roofOpacity.value = value;
            view.notifyChange(true);
      }
    );

var b = stylesRoof.onChange(() => {
    if (optionsRoof.stylesRoof==='Color'){
       $(colorStyleRoof.domElement).attr("hidden", false);
       $(textureStyleRoof.domElement).attr("hidden", true);
        ShadMatRoof.uniforms.styleStateRoof.value = 0;
        view.notifyChange();
    }
  
    
    else if (optionsRoof.stylesRoof==='Texture'){
        $(colorStyleRoof.domElement).attr("hidden", true);
        $(textureStyleRoof.domElement).attr("hidden", false);
        ShadMatRoof.uniforms.styleStateRoof.value = 1;
        view.notifyChange();
  }
  
  
});


var textureStyleRoof = RoofStyle.addFolder('TextureStyle')
$(textureStyleRoof.domElement).attr("hidden", true);



///////////////////////////////////////////////////////////


  var displacement = Style_criteria.add({displacement : 0}, 'displacement').min(0).max(100).step(0.5).name('displacement').onChange(
         function displacementVallue(f){

            ShadMatRoof.uniforms.displacement.value = f;
            ShadMatWalls.uniforms.displacement.value = f;
            //ShadMatEdges.uniforms.displacement.value = f;
            view.notifyChange(true);

      }
      );    
      var extrusion = Style_criteria.add({extrusion : 0}, 'extrusion').min(0).max(150).step(0.5).name('extrusion').onChange(
         function extrusionVallue(e){

            ShadMatRoof.uniforms.extrusion.value = e;
            ShadMatWalls.uniforms.extrusion.value = e;
            view.notifyChange(true);

      }
      ); 
      var baseMapStyle = Style_criteria.add({baseMapStyle : 1}, 'baseMapStyle').min(0).max(1).step(0.01).name('baseMapStyle').onChange(
         function baseMapStyle(e){

            //ShadMatRoof.uniforms.extrusion.value = e;
            //ShadMatWalls.uniforms.extrusion.value = e;
            view._layers[0].attachedLayers[5].opacity = e;
            baseMapStyle = e;
            view.notifyChange(true);

      }
      ); 
    console.log("baseMapStyle", baseMapStyle.object.baseMapStyle);  

   

    
//////////////////////////////Selecting buildings by clicking///////////////////:
//window.onclick = 
var FizzyTextt = function() { 
   
    this.Enable = function ssss() {
window.onclick = function picking(event) {
                var htmlInfo = document.getElementById('info');
                var intersects = view.pickObjectsAt(event, 2, 'WFS Building');
                var properties;
                var info;
                var batchId;
                //htmlInfo.innerHTML = ' ';
               
                if (intersects.length) {
                    batchId = intersects[0].object.geometry.attributes.batchId.array[intersects[0].face.a];
                    vv = batchId;
                    //console.log('buildingId',batchId);
                    ShadMatWalls.uniforms.buildingId.value = batchId;
                    ShadMatRoof.uniforms.buildingId.value = batchId;
                    properties = intersects[0].object.feature.geometry[batchId].properties;

                    //////////////getting the position of building by clicking on them
                    var vec3 = new THREE.Vector3();//pickingBuildings(event);  // Here you can call pickingBuildings if you want!
                    var geodesicPos = new THREE.Vector3();
                    if(vec3.z == 0){
                        geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                        let converted = geoposition.as('EPSG:4978'); 
                        //coordinates = converted._values; console.log(converted);
                        //vec3 = new THREE.Vector3(coordinates[0], coordinates[1], coordinates[2]);
                        vec3 = new THREE.Vector3(converted.x, converted.y, converted.z);
                    }
                    ShadMatWalls.uniforms.currentPos.value = vec3;
                    ShadMatRoof.uniforms.currentPos.value = vec3;
                    ShadMatEdges.uniforms.currentPos.value = vec3;
                    //console.log("ffff", vec3)

                    Object.keys(properties).map(function (objectKey) {
                        var value = properties[objectKey];
                        var key = objectKey.toString();
                       // if (key[0] !== '_' && key !== 'geometry_name') {
                           // info = value.toString();
                            //htmlInfo.innerHTML +='<li><b>' + key + ': </b>' + info + '</li>';
                        //}
                        var buildingId = properties.id.substring(19, properties.id.length);
                        buildingId = parseInt(buildingId);
                     
                        //return parseInt(buildingId);
                        //console.log("properties",properties.id);
                        view.notifyChange(true);
                    });
                    return properties;
                    //console.log(properties)
                }
           
        }
    }
 
};
var textt = new FizzyTextt();
  
  
  navv.add(textt, 'Enable');



  var FizzyText = function() { 
    this.SelectCenter = function ssss() { 
        window.onclick = function picking(event) {
               
                var intersects = view.pickObjectsAt(event, 2, 'WFS Building');
            
                if (intersects.length) {
                    //////////////getting the position of building by clicking on them
                    var vec3 = new THREE.Vector3();//pickingBuildings(event);  // Here you can call pickingBuildings if you want!
                    if(vec3.z == 0){
                        geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                        let converted = geoposition.as('EPSG:4978'); 
                       
                        vec3 = new THREE.Vector3(converted.x, converted.y, converted.z);
                    }
                    console.log("vec3", vec3)
                    ShadMatWalls.uniforms.centralPosBuffer.value = vec3;
                    ShadMatRoof.uniforms.centralPosBuffer.value = vec3;
                    //ShadMatEdges.uniforms.centralPosBuffer.value = vec3;
                   
                }
        }
    }
  };
  var text = new FizzyText();
  var buffer = menuGlobe.gui.addFolder('Buffer Analysis');
  buffer.add(text, 'SelectCenter');
  var bufferDistance = buffer.add({bufferDistance : 0}, 'bufferDistance').min(0).max(1000).step(1).name('bufferDistance').onChange(
      function heightValue(m){
          ShadMatWalls.uniforms.bufferDistance.value = m;
          ShadMatRoof.uniforms.bufferDistance.value = m;
          view.notifyChange(true);
         
      }
      
      );

    var Query = buffer.addFolder('Query on Attribute')
    var Zbottom = Query.addFolder('Zbottom')
  
  var queryZbottomMin = Zbottom.add({queryZbottomMin : 0.}, 'queryZbottomMin').min(0).max(100).step(1).name('min').onChange(
      function heightValue(m){
          ShadMatWalls.uniforms.queryZbottomMin.value = m;
          ShadMatRoof.uniforms.queryZbottomMin.value = m;
          view.notifyChange(true);
         
      }
      
      );
      var queryZbottomMax = Zbottom.add({queryZbottomMax : 100.}, 'queryZbottomMax').min(0).max(100).step(1).name('max').onChange(
      function heightValue(m){
          ShadMatWalls.uniforms.queryZbottomMax.value = m;
          ShadMatRoof.uniforms.queryZbottomMax.value = m;
          view.notifyChange(true);
         
      }
      
      );



      var selectZoomingPoint = function() { 
    this.SelectBuildingToZoom = function ssss() { 
        window.onclick = function picking(event) {
               
                var intersects = view.pickObjectsAt(event, 2, 'WFS Building');
            
                if (intersects.length) {
                    //////////////getting the position of building by clicking on them
                    var vec3 = new THREE.Vector3();//pickingBuildings(event);  // Here you can call pickingBuildings if you want!
                    
                    if(vec3.z == 0){
                        geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                         
                       
                        vec3 = new THREE.Vector3(geoposition.x, geoposition.y, geoposition.z);
                    }
                    this.positionOnGlobe = { longitude: /*2.423554*/vec3.x, latitude: /*48.845759,*/ vec3.y, altitude: 100 };
                    pathTravel.push({ coord: new itowns.Coordinates('EPSG:4326', positionOnGlobe.longitude, positionOnGlobe.latitude ), range: 100});

                }
        }
    }
  };
  var selection = new selectZoomingPoint();

var zooming = new zoomToSelectedObject();
  
  var nav = menuGlobe.gui.addFolder('Navigation');
  nav.add(zooming, 'ZoomToSelection');
  nav.add(selection, 'SelectBuildingToZoom');
  
        </script>

    </body>

</html>